import 'dart:async';
import 'package:analyzer/dart/element/element.dart';
import 'package:build/build.dart';
import 'package:source_gen/source_gen.dart';
import 'package:glob/glob.dart';
import 'package:json_annotation/json_annotation.dart';
import 'annotations.dart';

/// Configuration for JsonFactory generation
class JsonFactoryConfig {
  /// The output file name (default: 'json_factory.dart')
  final String fileName;
  
  /// The directory where the file will be generated (relative to lib/)
  final String outputDir;
  
  /// Package name for imports
  final String packageName;

  const JsonFactoryConfig({
    this.fileName = 'json_factory.dart',
    this.outputDir = '',
    required this.packageName,
  });
}

/// Represents a model class that needs JSON factory generation
class ModelInfo {
  /// The name of the model class
  final String name;

  /// The import path for the model class
  final String import;

  const ModelInfo({
    required this.name,
    required this.import,
  });
}

/// Automatically generates a centralized JsonFactory for all @jsonModel classes
class AutoJsonFactoryGenerator extends Builder {
  static const _dartFilePattern = 'lib/**.dart';
  final JsonFactoryConfig config;

  AutoJsonFactoryGenerator(this.config);

  @override
  Map<String, List<String>> get buildExtensions => {
    r'$lib$': [config.outputDir.isEmpty ? config.fileName : '${config.outputDir}/${config.fileName}']
  };

  @override
  Future<void> build(BuildStep buildStep) async {
    // Only trigger on lib folder to avoid multiple generations
    if (buildStep.inputId.path != 'lib/') return;
    
    final models = await _findAnnotatedModels(buildStep);
    
    if (models.isEmpty) {
      log.info('No @jsonModel classes found. Skipping JsonFactory generation.');
      return;
    }

    final outputPath = config.outputDir.isEmpty 
        ? 'lib/${config.fileName}'
        : 'lib/${config.outputDir}/${config.fileName}';
    
    final outputAssetId = AssetId(buildStep.inputId.package, outputPath);
    final generatedContent = _generateFactoryFile(models);

    await buildStep.writeAsString(outputAssetId, generatedContent);
    log.info('Generated JsonFactory with ${models.length} models: $outputPath');
  }

  /// Finds all model classes annotated with @jsonModel and @JsonSerializable
  Future<List<ModelInfo>> _findAnnotatedModels(BuildStep buildStep) async {
    final models = <ModelInfo>[];
    final dartFiles = Glob(_dartFilePattern);

    await for (final assetId in buildStep.findAssets(dartFiles)) {
      if (await buildStep.resolver.isLibrary(assetId)) {
        final library = await buildStep.resolver.libraryFor(assetId);
        final reader = LibraryReader(library);

        // Find all classes with @jsonModel annotation
        for (final annotatedElement in reader.annotatedWith(TypeChecker.fromRuntime(JsonModel))) {
          final element = annotatedElement.element;
          if (element is ClassElement) {
            // Check if class also has @JsonSerializable annotation
            final hasJsonSerializable = TypeChecker.fromRuntime(JsonSerializable)
                .hasAnnotationOfExact(element);

            if (hasJsonSerializable) {
              final importPath = _getImportPath(assetId, config.packageName);
              models.add(ModelInfo(
                name: element.name,
                import: importPath,
              ));
            }
          }
        }
      }
    }

    return models;
  }

  /// Generates the complete JsonFactory file content
  String _generateFactoryFile(List<ModelInfo> models) {
    final buffer = StringBuffer();
    
    // File header
    buffer.writeln('// GENERATED CODE - DO NOT MODIFY BY HAND');
    buffer.writeln('// Generated by json_factory_generator');
    buffer.writeln();
    
    // Imports
    buffer.writeln('import \'dart:core\';');
    for (final model in models) {
      buffer.writeln('import \'${model.import}\';');
    }
    buffer.writeln();
    
    // Type definitions
    buffer.writeln('typedef FromJsonFunc<T> = T Function(dynamic json);');
    buffer.writeln();

    // JsonFactory class
    buffer.writeln('/// Centralized factory for JSON serialization/deserialization');
    buffer.writeln('/// Auto-generated from @jsonModel annotated classes');
    buffer.writeln('class JsonFactory {');
    buffer.writeln('  JsonFactory._();');
    buffer.writeln();

    // Factories map
    buffer.writeln('  static final Map<Type, FromJsonFunc> _factories = {');
    for (final model in models) {
      buffer.writeln('    ${model.name}: (json) => ${model.name}.fromJson(json as Map<String, dynamic>),');
    }
    buffer.writeln('  };');
    buffer.writeln();

    // Type name map
    buffer.writeln('  static final Map<String, Type> _typeMap = {');
    for (final model in models) {
      buffer.writeln('    \'${model.name}\': ${model.name},');
    }
    buffer.writeln('  };');
    buffer.writeln();

    // List casters map
    buffer.writeln('  static final Map<Type, Function> _listCasters = {');
    for (final model in models) {
      buffer.writeln('    ${model.name}: (List<dynamic> list) => list.map((item) => ${model.name}.fromJson(item as Map<String, dynamic>)).toList(),');
    }
    buffer.writeln('  };');
    buffer.writeln();

    // fromJson method
    buffer.writeln('  /// Converts JSON to strongly typed object');
    buffer.writeln('  /// Supports both single objects and lists');
    buffer.writeln('  static T fromJson<T>(dynamic json) {');
    buffer.writeln('    if (json == null) {');
    buffer.writeln('      throw ArgumentError(\'Cannot convert null to \$T\');');
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln('    final type = T;');
    buffer.writeln();
    buffer.writeln('    // Handle List<Model> types');
    buffer.writeln('    if (type.toString().startsWith(\'List<\')) {');
    buffer.writeln('      if (json is! List) {');
    buffer.writeln('        throw ArgumentError(\'Expected List but got \${json.runtimeType}\');');
    buffer.writeln('      }');
    buffer.writeln();
    buffer.writeln('      final typeString = type.toString();');
    buffer.writeln('      final innerType = typeString.substring(5, typeString.length - 1);');
    buffer.writeln('      final modelType = _typeMap[innerType];');
    buffer.writeln();
    buffer.writeln('      if (modelType != null && _listCasters.containsKey(modelType)) {');
    buffer.writeln('        return _listCasters[modelType]!(json) as T;');
    buffer.writeln('      }');
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln('    // Handle single Model types');
    buffer.writeln('    final factory = _factories[type];');
    buffer.writeln('    if (factory != null) {');
    buffer.writeln('      return factory(json) as T;');
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln('    throw UnsupportedError(\'No factory found for type \$T\');');
    buffer.writeln('  }');
    buffer.writeln();

    // fromJsonByName method
    buffer.writeln('  /// Converts JSON to object by type name');
    buffer.writeln('  static dynamic fromJsonByName(String typeName, dynamic json) {');
    buffer.writeln('    final type = _typeMap[typeName];');
    buffer.writeln('    if (type == null) {');
    buffer.writeln('      throw UnsupportedError(\'No type found for name \$typeName\');');
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln('    final factory = _factories[type];');
    buffer.writeln('    if (factory == null) {');
    buffer.writeln('      throw UnsupportedError(\'No factory found for type \$type\');');
    buffer.writeln('    }');
    buffer.writeln();
    buffer.writeln('    return factory(json);');
    buffer.writeln('  }');
    buffer.writeln();

    // getSupportedTypes method
    buffer.writeln('  /// Returns list of all supported model types');
    buffer.writeln('  static List<String> getSupportedTypes() {');
    buffer.writeln('    return _typeMap.keys.toList();');
    buffer.writeln('  }');
    buffer.writeln();

    // isSupported method
    buffer.writeln('  /// Checks if a type is supported by this factory');
    buffer.writeln('  static bool isSupported<T>() {');
    buffer.writeln('    return _factories.containsKey(T);');
    buffer.writeln('  }');
    buffer.writeln();

    // isSupportedByName method
    buffer.writeln('  /// Checks if a type name is supported by this factory');
    buffer.writeln('  static bool isSupportedByName(String typeName) {');
    buffer.writeln('    return _typeMap.containsKey(typeName);');
    buffer.writeln('  }');
    buffer.writeln('}');

    return buffer.toString();
  }

  /// Gets the import path for a given asset
  String _getImportPath(AssetId assetId, String packageName) {
    final path = assetId.path;
    if (path.startsWith('lib/')) {
      return 'package:$packageName/${path.substring(4)}';
    }
    return path;
  }
}
