import 'package:build/build.dart';
import 'package:json_factory_generator/src/json_factory_generator_helper.dart';

/// Creates and configures a Builder for generating the JsonFactory code.
///
/// This builder implements a multi-step process:
/// 1. Scans all Dart files in the project
/// 2. Identifies classes marked with @jsonModel annotation
/// 3. Validates each class has proper fromJson/toJson methods
/// 4. Generates a centralized JsonFactory class for type-safe parsing
///
/// Configuration in build.yaml:
/// ```yaml
/// targets:
///   $default:
///     builders:
///       json_factory_generator:jsonFactoryBuilder:
///         options:
///           # Directory for generated file (default: lib/generated)
///           output_path: lib/generated
///           
///           # Name of generated file without .dart (default: json_factory)
///           output_file_name: json_factory
/// ```
///
/// The builder ensures:
/// - Type safety through strong static typing
/// - Proper null-safety handling
/// - Automatic type registration
/// - Efficient code generation with minimal boilerplate
Builder jsonFactoryBuilder(BuilderOptions options) {
  return JsonFactoryBuilder(options);
}

/// A custom Builder that generates the centralized JsonFactory implementation.
///
/// This builder creates a single, optimized factory class that handles JSON
/// parsing for all models in your project. It supports both manual JSON
/// serialization and code generated by json_serializable.
///
/// Features:
/// - Unified JSON parsing through JsonFactory.fromJson<T>()
/// - Full support for generics (List<T>, Map<K,V>, etc)
/// - Strong type checking at compile time
/// - Clear error messages for common issues
/// - Zero runtime setup required
/// - Automatic null safety handling
///
/// Configuration:
/// - output_path: Where to generate the factory (default: "lib/generated")
/// - output_file_name: Name of output file (default: "json_factory")
///
/// Best Practices:
/// - Keep the generated file under source control
/// - Run generation after adding new models
/// - Use with json_serializable for complex models
/// - Check generated code for type safety
class JsonFactoryBuilder implements Builder {
  final BuilderOptions options;

  JsonFactoryBuilder(this.options);

  @override
  Map<String, List<String>> get buildExtensions {
    final outputFileName =
        options.config['output_file_name'] as String? ?? 'json_factory';
    final outputPath = options.config['output_path'] as String? ?? 'lib';

    // Calculate relative path from lib/
    String relativePath;
    if (outputPath == 'lib') {
      relativePath = '$outputFileName.dart';
    } else if (outputPath.startsWith('lib/')) {
      relativePath = '${outputPath.substring(4)}/$outputFileName.dart';
    } else {
      relativePath = '$outputPath/$outputFileName.dart';
    }

    return {
      r'$lib$': [relativePath]
    };
  }

  @override
  Future<void> build(BuildStep buildStep) async {
    // Only run for the synthetic input
    if (buildStep.inputId.path != r'lib/$lib$') return;

    final outputFileName =
        options.config['output_file_name'] as String? ?? 'json_factory';
    final outputPath = options.config['output_path'] as String? ?? 'lib';

    final models = await JsonFactoryGeneratorHelper.findAnnotatedModels(buildStep);

    if (models.isEmpty) {
      log.warning('No @jsonModel classes found');
      return;
    }

    // Get package name for generating package imports
    final packageName = buildStep.inputId.package;
    final content = JsonFactoryGeneratorHelper.generateFactoryFile(models, packageName);

    // Use the configured output path and filename
    final outputFilePath = '$outputPath/$outputFileName.dart';

    final outputId = AssetId(
      buildStep.inputId.package,
      outputFilePath,
    );

    await buildStep.writeAsString(outputId, content);
  }
}
